use crate::ast::*;

grammar;

match {
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+([^/*][^*]*\*+)*/" => {},
    _
}

// CompUnit ::= [CompUnit] (Decl | FuncDef);
pub CompUnit: Box<CompUnit> = <items: TopLevel*> => Box::new(CompUnit { <> });

TopLevel: Box<TopLevel> = {
    Decl    => Box::new(TopLevel::Decl(<>)),
    FuncDef => Box::new(TopLevel::Func(<>)),
};

// Block         ::= "{" {BlockItem} "}";
Block: Box<Block> = "{" <block_items: BlockItem*> "}" => Box::new(Block { <> });

// FuncHead     ::= FuncType IDENT "("
FuncHead: (Type, String) = {
    "int" <ident: Ident> "("  => (Type::Int, ident),
    "void" <ident: Ident> "(" => (Type::Void, ident),
};

// FuncDef      ::= FuncHead [FuncFParams] ")" Block;
FuncDef: Box<FuncDef> = {
    <func_head: FuncHead> <params: FuncFParams?> ")" <block: Block> => {
        let (func_type, ident) = func_head;
        let params = params.unwrap_or(vec![]);
        Box::new(FuncDef {
            func_type,
            ident,
            params,
            block,
        })
    }
};


// FuncFParams ::= FuncFParam {"," FuncFParam};
FuncFParams: Vec<FuncFParam> = {
    <first_fparam: FuncFParam> <rest_fparams: ("," <FuncFParam>)*> => {
        let mut params = vec![first_fparam];
        for fparam in rest_fparams {
            params.push(fparam);
        }
        params
    }
};

// FuncFParam  ::= BType IDENT;
FuncFParam: FuncFParam = "int" <ident: Ident> => {
    FuncFParam { 
        func_type: Type::Int,
        ident: ident,
    }
};

// FuncRParams ::= Exp {"," Exp};
FuncRParams: Vec<Box<Exp>> = {
    <first_exp: Exp> <rest_exps: ("," <Exp>)*> => {
        let mut args = vec![first_exp];
        for exp in rest_exps {
            args.push(exp);
        }
        args
    }
};

Stmt: Box<Stmt> = {
    OpenStmt   => Box::new(Stmt::Open(<>)),
    ClosedStmt => Box::new(Stmt::Closed(<>)),
};

OpenStmt: Box<OpenStmt> = {
    "if" "(" <Exp> ")" <Stmt>                         => Box::new(OpenStmt::If(<>)),
    "if" "(" <Exp> ")" <ClosedStmt> "else" <OpenStmt> => Box::new(OpenStmt::Else(<>)),
    "while" "(" <Exp> ")" <OpenStmt>                  => Box::new(OpenStmt::While(<>)),
};

ClosedStmt: Box<ClosedStmt> = {
    SimpleStmt                                          => Box::new(ClosedStmt::Simple(<>)),
    "if" "(" <Exp> ")" <ClosedStmt> "else" <ClosedStmt> => Box::new(ClosedStmt::Else(<>)),
    "while" "(" <Exp> ")" <ClosedStmt>                  => Box::new(ClosedStmt::While(<>)),
};

SimpleStmt: Box<SimpleStmt> = {
    <LVal> "=" <Exp> ";" => Box::new(SimpleStmt::Assign(<>)),
    <Exp?> ";"           => Box::new(SimpleStmt::Eval(<>)),
    Block                => Box::new(SimpleStmt::Block(<>)),
    "break" ";"          => Box::new(SimpleStmt::Break),
    "continue" ";"       => Box::new(SimpleStmt::Continue),
    "return" <Exp?> ";"  => Box::new(SimpleStmt::Return(<>)),
};

Exp: Box<Exp> = <lor_exp: LOrExp> => Box::new(Exp { <> });

// Decl          ::= ConstDecl | VarDecl;
Decl: Box<Decl> = {
    ConstDecl => Box::new(Decl::Const(<>)),
    VarDecl   => Box::new(Decl::Var(<>)),
};

// VarDecl       ::= BType VarDef {"," VarDef} ";";
VarDecl: Box<VarDecl> = {
    "int" <first_def: VarDef> <rest_defs: ("," <VarDef>)*> ";" => {
        let mut var_defs = vec![first_def];
        for def in rest_defs {
            var_defs.push(def);
        }
        Box::new(VarDecl {
            btype: Type::Int,
            var_defs,
        })
    }
}

// ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
ConstDecl: Box<ConstDecl> = {
    "const" "int" <first_def: ConstDef> <rest_defs: ("," <ConstDef>)*> ";" => {
        let mut const_defs = vec![first_def];
        for def in rest_defs {
            const_defs.push(def);
        }
        Box::new(ConstDecl {
            btype: Type::Int,
            const_defs,
        })
    }
}

// VarDef        ::= IDENT | IDENT "=" InitVal;
VarDef: Box<VarDef> = {
    Ident                 => Box::new(VarDef::Ident(<>)),
    <Ident> "=" <InitVal> => Box::new(VarDef::Init(<>)),
};

// ConstDef      ::= IDENT "=" ConstInitVal;
ConstDef: Box<ConstDef> = <ident: Ident> "=" <const_init_val: ConstInitVal> => Box::new(ConstDef { <> });

// ConstInitVal  ::= ConstExp;
ConstInitVal: Box<ConstInitVal> = <const_exp: ConstExp> => Box::new(ConstInitVal { <> });

// BlockItem     ::= Decl | Stmt;
BlockItem: Box<BlockItem> = {
    Decl => Box::new(BlockItem::Decl(<>)),
    Stmt => Box::new(BlockItem::Stmt(<>)),
};

// LVal          ::= IDENT;
LVal: Box<LVal> = <ident: Ident> => Box::new(LVal { <> });

// InitVal       ::= Exp;
InitVal: Box<InitVal> = <exp: Exp> => Box::new(InitVal { <> });

// ConstExp      ::= Exp;
ConstExp: Box<ConstExp> = <exp: Exp> => Box::new(ConstExp { <> });

// RelExp      ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp: Box<RelExp> = {
    AddExp              => Box::new(RelExp::AddExp(<>)),
    RelExp RelOp AddExp => Box::new(RelExp::Rel(<>)),
};

// EqExp       ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp: Box<EqExp> = {
    RelExp            => Box::new(EqExp::RelExp(<>)),
    EqExp EqOp RelExp => Box::new(EqExp::Eq(<>)),
};

// LAndExp     ::= EqExp | LAndExp "&&" EqExp;
LAndExp: Box<LAndExp> = {
    EqExp                  => Box::new(LAndExp::EqExp(<>)),
    <LAndExp> "&&" <EqExp> => Box::new(LAndExp::LAnd(<>)),
};

// LOrExp      ::= LAndExp | LOrExp "||" LAndExp;
LOrExp: Box<LOrExp> = {
    LAndExp                 => Box::new(LOrExp::LAndExp(<>)),
    <LOrExp> "||" <LAndExp> => Box::new(LOrExp::LOr(<>)),
};

AddExp: Box<AddExp> = {
    MulExp              => Box::new(AddExp::MulExp(<>)),
    AddExp AddOp MulExp => Box::new(AddExp::Binary(<>)),
};

MulExp: Box<MulExp> = {
    UnaryExp              => Box::new(MulExp::Unary(<>)),
    MulExp MulOp UnaryExp => Box::new(MulExp::Binary(<>)),
};

// PrimaryExp    ::= "(" Exp ")" | LVal | Number;
PrimaryExp: Box<PrimaryExp> = {
    "(" <Exp> ")" => Box::new(PrimaryExp::Paren(<>)),
    LVal          => Box::new(PrimaryExp::LVal(<>)),
    Number        => Box::new(PrimaryExp::Number(<>)),
};

UnaryExp: Box<UnaryExp> = {
    PrimaryExp                     => Box::new(UnaryExp::Primary(<>)),
    <ident: Ident> "(" <params: FuncRParams?> ")" => {
        let params = params.unwrap_or(vec![]);
        Box::new(UnaryExp::Call(ident, params))
    },
    UnaryOp UnaryExp               => Box::new(UnaryExp::UnaryOp(<>)),
};

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Minus,
};

EqOp: EqOp = {
    "==" => EqOp::Equal,
    "!=" => EqOp::NotEqual,
};

RelOp: RelOp = {
    "<"   => RelOp::Less,
    ">"   => RelOp::Greater,
    "<=" => RelOp::LessEq,
    ">="  => RelOp::GreaterEq,
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "!" => UnaryOp::Not,
};

Number: i32 = <num: IntConst> => <>;

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}