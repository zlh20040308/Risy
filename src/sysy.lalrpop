use crate::ast::*;


// lalrpop 里的约定
grammar;

// 约束 lexer 的行为
match {
  // 跳过空白符和注释
  r"\s*" => {},
  r"//[^\n\r]*[\n\r]*" => {},
  r"/\*[^*]*\*+([^/*][^*]*\*+)*/" => {},
  // 剩下的情况采用默认方式处理
  _
}

pub CompUnit: CompUnit = <func_def: FuncDef> => CompUnit { <> };

FuncDef: Box<FuncDef> = {
  <func_type: FuncType> <ident: Ident> "(" ")" <block: Block> => {
    Box::new(FuncDef { <> })
  }
}

FuncType: FuncType = "int" => FuncType::Int;

Block: Box<Block> = "{" <stmt: Stmt> "}" => Box::new(Block { <> });

Stmt: Box<Stmt> = "return" <exp: Exp> ";" => Box::new(Stmt { <> });

Exp: Box<Exp> = <lor_exp: LOrExp> => Box::new(Exp { <> });

// RelExp      ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp: Box<RelExp> = {
    AddExp              => Box::new(RelExp::AddExp(<>)),
    RelExp RelOp AddExp => Box::new(RelExp::Rel(<>)),
};

// EqExp       ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp: Box<EqExp> = {
    RelExp            => Box::new(EqExp::RelExp(<>)),
    EqExp EqOp RelExp => Box::new(EqExp::Eq(<>)),
};

// LAndExp     ::= EqExp | LAndExp "&&" EqExp;
LAndExp: Box<LAndExp> = {
    EqExp                            => Box::new(LAndExp::EqExp(<>)),
    <lhs: LAndExp> "&&" <rhs: EqExp> => Box::new(LAndExp::LAnd(<>)),
};

// LOrExp      ::= LAndExp | LOrExp "||" LAndExp;
LOrExp: Box<LOrExp> = {
    LAndExp                           => Box::new(LOrExp::LAndExp(<>)),
    <lhs: LOrExp> "||" <rhs: LAndExp> => Box::new(LOrExp::LOr(<>)),
};

AddExp: Box<AddExp> = {
    MulExp              => Box::new(AddExp::MulExp(<>)),
    AddExp AddOp MulExp => Box::new(AddExp::Binary(<>)),
};

MulExp: Box<MulExp> = {
    UnaryExp              => Box::new(MulExp::Unary(<>)),
    MulExp MulOp UnaryExp => Box::new(MulExp::Binary(<>)),
};

PrimaryExp: Box<PrimaryExp> = {
    "(" <exp: Exp> ")" => Box::new(PrimaryExp::Paren(<>)),
    Number             => Box::new(PrimaryExp::Number(<>)),
};

UnaryExp: Box<UnaryExp> = {
    PrimaryExp       => Box::new(UnaryExp::Primary(<>)),
    UnaryOp UnaryExp => Box::new(UnaryExp::UnaryOp(<>)),
};

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Minus,
};

EqOp: EqOp = {
    "==" => EqOp::Equal,
    "!=" => EqOp::NotEqual,
};

RelOp: RelOp = {
    "<"   => RelOp::Less,
    ">"   => RelOp::Greater,
    "<=" => RelOp::LessEq,
    ">="  => RelOp::GreaterEq,
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "!" => UnaryOp::Not,
};

Number: i32 = <num: IntConst> => <>;

// 如果匹配到标识符, 就返回这个字符串
// 一对尖括号在此处指代的是正则表达式匹配到的字符串 (&str)
// 关于尖括号到底代表什么, 请 RTFM
Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

// 对整数字面量的处理方式: 把匹配到的字符串按对应进制转换成数字
IntConst: i32 = {
  r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
  r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
  r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}