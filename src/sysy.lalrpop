use crate::ast::*;


// lalrpop 里的约定
grammar;

// 约束 lexer 的行为
match {
    // 跳过空白符和注释
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
    r"/\*[^*]*\*+([^/*][^*]*\*+)*/" => {},
    // 剩下的情况采用默认方式处理
    _
}

pub CompUnit: CompUnit = <func_def: FuncDef> => CompUnit { <> };

FuncDef: Box<FuncDef> = {
    <func_type: FuncType> <ident: Ident> "(" ")" <block: Block> => {
        Box::new(FuncDef { <> })
    }
}

FuncType: FuncType = "int" => FuncType::Int;

// Block         ::= "{" {BlockItem} "}";
Block: Box<Block> = "{" <block_items: BlockItem*> "}" => Box::new(Block { <> });

Stmt: Box<Stmt> = {
    OpenStmt   => Box::new(Stmt::Open(<>)),
    ClosedStmt => Box::new(Stmt::Closed(<>)),
};

OpenStmt: Box<OpenStmt> = {
    "if" "(" <Exp> ")" <Stmt>                         => Box::new(OpenStmt::If(<>)),
    "if" "(" <Exp> ")" <ClosedStmt> "else" <OpenStmt> => Box::new(OpenStmt::Else(<>)),
    "while" "(" <Exp> ")" <OpenStmt>                  => Box::new(OpenStmt::While(<>)),
};

ClosedStmt: Box<ClosedStmt> = {
    SimpleStmt                                          => Box::new(ClosedStmt::Simple(<>)),
    "if" "(" <Exp> ")" <ClosedStmt> "else" <ClosedStmt> => Box::new(ClosedStmt::Else(<>)),
    "while" "(" <Exp> ")" <ClosedStmt>                  => Box::new(ClosedStmt::While(<>)),
};

SimpleStmt: Box<SimpleStmt> = {
    <LVal> "=" <Exp> ";" => Box::new(SimpleStmt::Assign(<>)),
    <Exp?> ";"           => Box::new(SimpleStmt::Eval(<>)),
    Block                => Box::new(SimpleStmt::Block(<>)),
    "break" ";"          => Box::new(SimpleStmt::Break),
    "continue" ";"       => Box::new(SimpleStmt::Continue),
    "return" <Exp?> ";"  => Box::new(SimpleStmt::Return(<>)),
};

Exp: Box<Exp> = <lor_exp: LOrExp> => Box::new(Exp { <> });

// Decl          ::= ConstDecl | VarDecl;
Decl: Box<Decl> = {
    ConstDecl => Box::new(Decl::Const(<>)),
    VarDecl   => Box::new(Decl::Var(<>)),
};

// VarDecl       ::= BType VarDef {"," VarDef} ";";
VarDecl: Box<VarDecl> = {
    <btype: BType> <first_def: VarDef> <rest_defs: ("," <VarDef>)*> ";" => {
        let mut var_defs = vec![first_def];
        for def in rest_defs {
            var_defs.push(def);
        }
        Box::new(VarDecl {
            btype,
            var_defs,
        })
    }
}

// ConstDecl     ::= "const" BType ConstDef {"," ConstDef} ";";
ConstDecl: Box<ConstDecl> = {
    "const" <btype: BType> <first_def: ConstDef> <rest_defs: ("," <ConstDef>)*> ";" => {
        let mut const_defs = vec![first_def];
        for def in rest_defs {
            const_defs.push(def);
        }
        Box::new(ConstDecl {
            btype,
            const_defs,
        })
    }
}

// BType         ::= "int";
BType: String = "int" => <>.to_string();

// VarDef        ::= IDENT | IDENT "=" InitVal;
VarDef: Box<VarDef> = {
    Ident                 => Box::new(VarDef::Ident(<>)),
    <Ident> "=" <InitVal> => Box::new(VarDef::Init(<>)),
};

// ConstDef      ::= IDENT "=" ConstInitVal;
ConstDef: Box<ConstDef> = <ident: Ident> "=" <const_init_val: ConstInitVal> => Box::new(ConstDef { <> });

// ConstInitVal  ::= ConstExp;
ConstInitVal: Box<ConstInitVal> = <const_exp: ConstExp> => Box::new(ConstInitVal { <> });

// BlockItem     ::= Decl | Stmt;
BlockItem: Box<BlockItem> = {
    Decl => Box::new(BlockItem::Decl(<>)),
    Stmt => Box::new(BlockItem::Stmt(<>)),
};

// LVal          ::= IDENT;
LVal: Box<LVal> = <ident: Ident> => Box::new(LVal { <> });

// InitVal       ::= Exp;
InitVal: Box<InitVal> = <exp: Exp> => Box::new(InitVal { <> });

// ConstExp      ::= Exp;
ConstExp: Box<ConstExp> = <exp: Exp> => Box::new(ConstExp { <> });

// RelExp      ::= AddExp | RelExp ("<" | ">" | "<=" | ">=") AddExp;
RelExp: Box<RelExp> = {
    AddExp              => Box::new(RelExp::AddExp(<>)),
    RelExp RelOp AddExp => Box::new(RelExp::Rel(<>)),
};

// EqExp       ::= RelExp | EqExp ("==" | "!=") RelExp;
EqExp: Box<EqExp> = {
    RelExp            => Box::new(EqExp::RelExp(<>)),
    EqExp EqOp RelExp => Box::new(EqExp::Eq(<>)),
};

// LAndExp     ::= EqExp | LAndExp "&&" EqExp;
LAndExp: Box<LAndExp> = {
    EqExp                  => Box::new(LAndExp::EqExp(<>)),
    <LAndExp> "&&" <EqExp> => Box::new(LAndExp::LAnd(<>)),
};

// LOrExp      ::= LAndExp | LOrExp "||" LAndExp;
LOrExp: Box<LOrExp> = {
    LAndExp                 => Box::new(LOrExp::LAndExp(<>)),
    <LOrExp> "||" <LAndExp> => Box::new(LOrExp::LOr(<>)),
};

AddExp: Box<AddExp> = {
    MulExp              => Box::new(AddExp::MulExp(<>)),
    AddExp AddOp MulExp => Box::new(AddExp::Binary(<>)),
};

MulExp: Box<MulExp> = {
    UnaryExp              => Box::new(MulExp::Unary(<>)),
    MulExp MulOp UnaryExp => Box::new(MulExp::Binary(<>)),
};

// PrimaryExp    ::= "(" Exp ")" | LVal | Number;
PrimaryExp: Box<PrimaryExp> = {
    "(" <Exp> ")" => Box::new(PrimaryExp::Paren(<>)),
    LVal          => Box::new(PrimaryExp::LVal(<>)),
    Number        => Box::new(PrimaryExp::Number(<>)),
};

UnaryExp: Box<UnaryExp> = {
    PrimaryExp       => Box::new(UnaryExp::Primary(<>)),
    UnaryOp UnaryExp => Box::new(UnaryExp::UnaryOp(<>)),
};

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Minus,
};

EqOp: EqOp = {
    "==" => EqOp::Equal,
    "!=" => EqOp::NotEqual,
};

RelOp: RelOp = {
    "<"   => RelOp::Less,
    ">"   => RelOp::Greater,
    "<=" => RelOp::LessEq,
    ">="  => RelOp::GreaterEq,
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

UnaryOp: UnaryOp = {
    "+" => UnaryOp::Plus,
    "-" => UnaryOp::Minus,
    "!" => UnaryOp::Not,
};

Number: i32 = <num: IntConst> => <>;

Ident: String = r"[_a-zA-Z][_a-zA-Z0-9]*" => <>.to_string();

IntConst: i32 = {
    r"[1-9][0-9]*" => i32::from_str_radix(<>, 10).unwrap(),
    r"0[0-7]*" => i32::from_str_radix(<>, 8).unwrap(),
    r"0[xX][0-9a-fA-F]+" => i32::from_str_radix(&<>[2..], 16).unwrap(),
}